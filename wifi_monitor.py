import os
import re
import select
import sys
import json
import subprocess
import copy
import time
import csv
from collections import defaultdict
from termcolor import colored

# --- Scapy Import --- #
try:
    from scapy.all import sniff, wrpcap, rdpcap, sendp, Dot11, Ether, IP, TCP, UDP, DNS, DNSRR, RadioTap, Dot11Deauth, DNSQR
    from scapy.layers.tls.handshake import TLSClientHello
    from scapy.error import Scapy_Exception
except ImportError:
    print(colored("[-] Scapy is not installed. Please run 'pip install scapy'", "red"))
    exit(1)

# --- Configuration & Heuristics ---
SCAN_DURATION = 15  # seconds for network discovery
WHITELIST_FILE = "whitelist.json"
AIRODUMP_PREFIX = "wifi_scan_capture"
CAPTURE_DURATION = 300  # 5 minutes for traffic capture
IP_TO_HOSTNAME = {}  # Cache for IP -> Hostname mapping

HEURISTIC_MAP = {
    'Browsing': {'TCP': {80, 443}},
    'Streaming': {'TCP': {1935, 554, 1755}, 'UDP': {1935, 554, 1755}},
    'VoIP': {'UDP': {5060, 5004}},
    'File Transfer': {'TCP': {20, 21, 22}},
    'Gaming': {'UDP': {3074, 27015, 25565}}
}

# --- Core Functions ---

def check_dependencies():
    """Checks if essential command-line tools are installed."""
    dependencies = ['iwconfig', 'iwlist', 'ifconfig', 'arp-scan', 'airodump-ng', 'wireshark', 'bettercap']
    for cmd in dependencies:
        if subprocess.run(["which", cmd], capture_output=True).returncode != 0:
            print(colored(f"[-] Error: '{cmd}' is not installed. Please install it to continue.", "red"))
            exit(1)

def sanitize_mac_address(mac_string):
    """Rebuilds a MAC address into a standardized format (e.g., 'aa:bb:cc:dd:ee:ff')."""
    # Find all hexadecimal characters, ignoring case
    hex_digits = re.findall(r'[0-9a-f]', str(mac_string).lower())
    if len(hex_digits) != 12:
        return None  # Invalid MAC address
    
    # Join the digits and insert colons
    return ':'.join(''.join(pair) for pair in zip(hex_digits[0::2], hex_digits[1::2]))

def load_whitelisted_macs():
    """Loads, sanitizes, and validates the list of whitelisted MAC addresses, reporting any issues."""
    if not os.path.exists(WHITELIST_FILE):
        print(colored(f"[-] Whitelist file '{WHITELIST_FILE}' not found.", "red"))
        return []
    try:
        with open(WHITELIST_FILE, 'r') as f:
            data = json.load(f)
        raw_macs = data.get("authorized_macs", [])
        sanitized_macs = []
        seen_macs = set()
        malformed_entries = []
        duplicate_entries = []

        for mac in raw_macs:
            sanitized = sanitize_mac_address(mac)
            if sanitized is None:
                malformed_entries.append(mac)
                continue
            
            if sanitized in seen_macs:
                duplicate_entries.append(mac)
            else:
                sanitized_macs.append(sanitized)
                seen_macs.add(sanitized)

        if malformed_entries or duplicate_entries:
            print(colored("\n--- Whitelist Notice ---", "yellow"))
            if malformed_entries:
                print(colored("[!] The following entries in your whitelist.json are malformed and were ignored:", "yellow"))
                for entry in malformed_entries:
                    print(f"    - '{entry}'")
            if duplicate_entries:
                print(colored("[!] The following duplicate entries in your whitelist.json were ignored:", "yellow"))
                for entry in duplicate_entries:
                    print(f"    - '{entry}'")
            print(colored("------------------------\n", "yellow"))
            time.sleep(4) # Give user time to read

        return sanitized_macs
    except (json.JSONDecodeError, Exception) as e:
        print(colored(f"[-] Error loading whitelist: {e}", "red"))
        return []

def cleanup_scan_files(prefix=AIRODUMP_PREFIX):
    """Removes files generated by airodump-ng with a given prefix."""
    for filename in os.listdir('.'):
        if filename.startswith(prefix):
            try:
                os.remove(filename)
            except OSError as e:
                print(colored(f"[-] Warning: Could not remove file {filename}: {e}", "yellow"))

def get_active_network_info():
    """Finds the active connected interface, its ESSID, and channel."""
    try:
        # Find the connected interface and ESSID using iwconfig
        iwconfig_output = subprocess.check_output(["iwconfig"], stderr=subprocess.STDOUT).decode()
        connected_interface = None
        essid = None
        for line in iwconfig_output.split("\n"):
            if "ESSID:" in line and "off/any" not in line:
                connected_interface = line.split()[0]
                essid_match = re.search(r'ESSID:"([^"]+)"', line)
                if essid_match:
                    essid = essid_match.group(1)
                break
        
        if not connected_interface:
            return None, None, None

        # Get the channel for that interface using iwlist
        iwlist_output = subprocess.check_output(["iwlist", connected_interface, "channel"], stderr=subprocess.STDOUT).decode()
        channel = None
        for line in iwlist_output.split("\n"):
            if "Current Frequency" in line:
                channel_search = re.search(r"Channel (\d+)", line)
                if channel_search:
                    channel = int(channel_search.group(1))
                    break
        
        return connected_interface, essid, channel

    except (subprocess.CalledProcessError, FileNotFoundError):
        return None, None, None

def get_all_wireless_interfaces():
    """Returns a list of all available wireless interfaces."""
    interfaces = []
    try:
        output = subprocess.check_output(["iwconfig"], stderr=subprocess.STDOUT).decode()
        for line in output.split("\n"):
            if line and not line.startswith(' ') and 'no wireless extensions' not in line:
                if 'IEEE 802.11' in line or 'Mode:' in line:
                    interfaces.append(line.split()[0])
    except (subprocess.CalledProcessError, FileNotFoundError):
        pass
    return interfaces

def select_interface():
    """Allows the user to select a wireless interface from a list."""
    interfaces = get_all_wireless_interfaces()
    if not interfaces:
        print(colored("[-] No wireless interfaces found.", "red"))
        return None

    print(colored("\nAvailable wireless interfaces:", "cyan"))
    for i, iface in enumerate(interfaces):
        print(f"  ({i + 1}) {iface}")

    while True:
        try:
            choice = input(colored("\nSelect an interface to use (or press Enter to cancel): ", "blue")).strip()
            if not choice:
                return None
            choice_idx = int(choice) - 1
            if 0 <= choice_idx < len(interfaces):
                return interfaces[choice_idx]
            else:
                print(colored("[-] Invalid selection. Please try again.", "red"))
        except (ValueError, IndexError):
            print(colored("[-] Invalid input. Please enter a number from the list.", "red"))

def set_monitor_mode(interface, channel):
    """Enables monitor mode on a given interface and sets the channel."""
    print(colored(f"[*] Setting {interface} to monitor mode on channel {channel}...", "blue"))
    try:
        subprocess.run(["ifconfig", interface, "down"], check=True)
        subprocess.run(["iwconfig", interface, "mode", "monitor"], check=True)
        subprocess.run(["ifconfig", interface, "up"], check=True)
        subprocess.run(["iwconfig", interface, "channel", str(channel)], check=True)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError) as e:
        print(colored(f"[-] Failed to set monitor mode on {interface}: {e}", "red"))
        return False

def set_managed_mode(interface):
    """Disables monitor mode and returns the interface to managed mode."""
    print(colored(f"\n[*] Restoring {interface} to managed mode...", "blue"))
    try:
        subprocess.run(["ifconfig", interface, "down"], check=True)
        subprocess.run(["iwconfig", interface, "mode", "managed"], check=True)
        subprocess.run(["ifconfig", interface, "up"], check=True)
        print(colored(f"[*] {interface} restored successfully.", "green"))
        return True
    except (subprocess.CalledProcessError, FileNotFoundError) as e:
        print(colored(f"[-] Failed to restore managed mode on {interface}: {e}", "red"))
        return False

# --- Mode 1: Real-time LAN Monitoring & Deauthentication ---

def get_connected_bssid(interface):
    """Gets the BSSID of the network the interface is connected to."""
    try:
        output = subprocess.check_output(["iwconfig", interface], stderr=subprocess.STDOUT).decode()
        for line in output.split("\n"):
            if "Access Point:" in line:
                return line.split("Access Point:")[1].strip()
    except Exception:
        return None

def discover_devices_on_lan(interface):
    """Discovers devices on the LAN using arp-scan."""
    print(colored("\n[*] Scanning for devices on the local network...", "blue"))
    cmd = ["arp-scan", "--localnet", "--interface", interface]
    try:
        output = subprocess.check_output(cmd, stderr=subprocess.STDOUT).decode()
        devices = {}
        for line in output.splitlines():
            parts = line.split()
            if len(parts) >= 2 and re.match(r'([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}', parts[1]):
                ip, mac = parts[0], parts[1]
                sanitized_mac = sanitize_mac_address(mac)
                devices[sanitized_mac] = ip
        return devices
    except subprocess.CalledProcessError as e:
        output = e.output.decode()
        if "permission denied" in output.lower() or "operation not permitted" in output.lower():
            print(colored("[-] Error: arp-scan requires root privileges. Please run this script with 'sudo'.", "red"))
        else:
            print(colored(f"[-] Error running arp-scan: {output}", "red"))
        return {}
    except FileNotFoundError:
        print(colored("[-] Command 'arp-scan' not found. Please install it to use this feature.", "red"))
        return {}

def send_deauth_packets(targets, bssid, monitor_interface):
    """Sends deauthentication packets to a list of target MAC addresses."""
    print(colored(f"\n[*] Sending deauthentication packets via {monitor_interface}...", "magenta"))
    print(colored("Press Ctrl+C to stop.", "yellow"))
    
    packets = []
    for target_mac in targets:
        packet = RadioTap() / Dot11(type=0, subtype=12, addr1=target_mac, addr2=bssid, addr3=bssid) / Dot11Deauth(reason=7)
        packets.append(packet)

    try:
        while True:
            for p in packets:
                sendp(p, iface=monitor_interface, count=5, inter=0.1, verbose=0)
            print(f".", end="", flush=True)
            time.sleep(1)
    except KeyboardInterrupt:
        print(colored("\n[+] Stopped sending deauth packets.", "green"))
    except Exception as e:
        print(colored(f"\n[-] An error occurred while sending packets: {e}", "red"))

def run_real_time_monitor():
    """Monitors the LAN for unauthorized devices and allows deauthentication with auto-refresh."""
    connected_interface, _, _ = get_active_network_info()
    if not connected_interface:
        print(colored("[-] Could not find a connected interface for LAN monitoring.", "red"))
        return

    bssid = get_connected_bssid(connected_interface)
    if not bssid:
        print(colored(f"[-] Could not determine BSSID for {connected_interface}. Deauthentication will not be possible.", "red"))
    
    unauthorized_devices = {}
    
    while True:
        whitelisted_macs = load_whitelisted_macs()  # Reload whitelist every cycle
        all_devices = discover_devices_on_lan(connected_interface)
        
        # We don't clear screen until we have new data
        if not all_devices:
            print(colored("No devices found. Retrying in 10 seconds...", "yellow"))
            time.sleep(10)
            continue

        whitelisted_macs_set = set(whitelisted_macs)
        all_devices_mac_set = set(all_devices.keys())

        unauthorized_online = {mac: all_devices[mac] for mac in all_devices_mac_set - whitelisted_macs_set}

        os.system('clear' if os.name == 'posix' else 'cls')
        print(colored("--- ðŸ“¡ Real-time LAN Monitoring (Auto-refreshing) ---", "cyan"))
        print(f"[*] Monitoring on interface: {connected_interface} | AP BSSID: {bssid or 'N/A'}")
        print(f"[*] Whitelist is reloaded and scan refreshes automatically.")
        print("-" * 70)

        print(colored("\n--- Authorized Devices ---", "green"))
        if whitelisted_macs:
            for mac in sorted(whitelisted_macs):
                print(f"  [+] {mac.upper()}")
        else:
            print("  (Whitelist is empty)")

        print(colored("\n--- Unauthorized Devices ---", "magenta"))
        if unauthorized_online:
            for mac in sorted(unauthorized_online.keys()):
                print(f"  [!] {mac.upper()}")
        else:
            print("  (None detected)")
        
        print("\n" + "-" * 70)
        print(colored("Menu:", "yellow"))
        if unauthorized_online and bssid:
            print("  (D) Disconnect all Unauthorized Devices")
        print("  (Q) Quit to Main Menu")
        print(colored("Waiting for input or auto-refreshing in 60 seconds...", "blue"))

        try:
            # Non-blocking input with a 60-second timeout
            rlist, _, _ = select.select([sys.stdin], [], [], 60)
            choice = ''
            if rlist:
                choice = sys.stdin.readline().strip().lower()

            if choice == 'd' and unauthorized_online and bssid:
                print(colored("\n--- Deauthentication Mode ---", "magenta"))
                print(colored("[!] This will attempt to disconnect all unauthorized devices.", "yellow"))
                print(colored("[!] A separate wireless interface in MONITOR MODE is required.", "yellow"))
                
                monitor_interface = select_interface()
                if monitor_interface:
                    send_deauth_packets(list(unauthorized_online.keys()), bssid, monitor_interface)
                else:
                    print(colored("[-] Deauthentication cancelled.", "red"))
                    time.sleep(2)
            elif choice == 'q':
                return
            # If no input or invalid input, the loop continues and refreshes
        
        except (KeyboardInterrupt, EOFError):
            print(colored("\n[*] Returning to main menu.", "blue"))
            return

# --- Heuristic Analysis Configuration ---
APP_HOSTNAMES = {
    'WhatsApp': ['whatsapp.net', 'whatsapp.com'],
    'Spotify': ['spotify.com', 'spoti.fi', 'scdn.co'],
    'Instagram': ['instagram.com', 'cdninstagram.com'],
    'Facebook': ['facebook.com', 'fbcdn.net'],
    'TikTok': ['tiktok.com', 'tiktokcdn.com', 'musical.ly'],
    'Netflix': ['netflix.com', 'nflxvideo.net'],
    'YouTube': ['youtube.com', 'googlevideo.com'],
    'InShot': ['inshot.com', 'inshotapp.com'],
}

TRAFFIC_RULES = {
    'Browsing': {'TCP': [80, 443]},
    'Streaming Media': {'TCP': [554, 1755, 1935, 8080], 'UDP': [554, 1755, 1935]},
    'VoIP': {'UDP': list(range(10000, 20001)) + [5060, 5061, 5004]},
    'File Transfer': {'TCP': [20, 21, 22, 989, 990]},
    'Email': {'TCP': [25, 465, 587, 110, 143, 993]},
    'Gaming': {'TCP': list(range(27005, 27051)), 'UDP': [3074, 27015, 25565] + list(range(27005, 27051))},
    'Remote Access': {'TCP': [22, 3389, 5900]},
    'DNS': {'TCP': [53], 'UDP': [53]},
    'VPN / Tunneling': {'TCP': [1194, 443], 'UDP': [1194, 1701, 4500, 500]},
    'Cloud Services': {'TCP': [443, 8443, 80], 'UDP': [443, 8443, 80]},
}

def classify_packet(packet):
    """
    Classifies a packet, returning both specific hostname and general traffic type.
    Returns: (str: traffic_type, str: specific_hostname_or_app)
    """
    # Layer 1: Application/Hostname identification via DNS/TLS
    hostname = ""
    if packet.haslayer(DNS) and packet.getlayer(DNS).qr == 0:  # DNS Query
        try:
            hostname = packet[DNSQR].qname.decode('utf-8').lower().rstrip('.')
        except (IndexError, AttributeError):
            pass
    elif packet.haslayer(TLSClientHello):
        try:
            for ext in packet[TLSClientHello].extensions:
                if ext.type == 0:  # server_name
                    hostname = ext.servernames[0].servername.decode('utf-8').lower()
                    break
        except (IndexError, AttributeError):
            pass

    # Determine application based on hostname
    app_type = None
    if hostname:
        for app, hosts in APP_HOSTNAMES.items():
            for host in hosts:
                if host in hostname:
                    app_type = app
                    break
            if app_type: break

    # Layer 2: Port-based heuristic classification (fallback)
    port_type = 'Unknown'
    if packet.haslayer(TCP):
        proto = 'TCP'
        sport, dport = packet[TCP].sport, packet[TCP].dport
    elif packet.haslayer(UDP):
        proto = 'UDP'
        sport, dport = packet[UDP].sport, packet[UDP].dport
    else:
        return 'Unknown', hostname or 'N/A'

    for p_type, rules in TRAFFIC_RULES.items():
        if proto in rules:
            for port in rules[proto]:
                if sport == port or dport == port:
                    port_type = p_type
                    break
            if port_type != 'Unknown': break

    final_type = app_type or port_type
    display_name = hostname if (hostname and not app_type) else final_type
    
    return final_type, display_name

def scan_for_networks(monitor_interface):
    """Scans for WiFi networks using airodump-ng."""
    scan_prefix = f"airodump_scan_{int(time.time())}"
    scan_csv_file = f"{scan_prefix}-01.csv"
    
    print(colored(f"[*] Scanning for networks on {monitor_interface} for {SCAN_DURATION} seconds...", "blue"))
    
    airodump_process = None
    try:
        airodump_process = subprocess.Popen(
            ["airodump-ng", "-w", scan_prefix, "--output-format", "csv", monitor_interface],
            stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
        )
        time.sleep(SCAN_DURATION)
    finally:
        if airodump_process:
            airodump_process.terminate()
            airodump_process.wait()

    networks = []
    try:
        with open(scan_csv_file, 'r', newline='') as csvfile:
            reader = csv.reader(csvfile)
            ap_list_started = False
            for row in reader:
                if not row: continue
                if 'BSSID' in row[0]:
                    if not ap_list_started:
                        ap_list_started = True
                        continue
                    else:
                        break # End of APs, start of clients
                if ap_list_started:
                    try:
                        bssid = row[0].strip()
                        essid = row[13].strip()
                        if bssid and essid and '<length:' not in essid:
                            networks.append({
                                'bssid': bssid,
                                'channel': int(row[3].strip()),
                                'privacy': row[5].strip(),
                                'essid': essid
                            })
                    except (IndexError, ValueError):
                        continue
    except FileNotFoundError:
        print(colored("[-] Airodump-ng scan did not produce an output file.", "red"))
    finally:
        cleanup_scan_files(prefix=scan_prefix)
        
    return networks

def display_analysis_summary(device_stats):
    """Prints a summary of the live traffic analysis."""
    print(colored("\n--- Live Traffic Analysis Report ---", "cyan"))
    if not device_stats:
        print(colored("No IP traffic was captured.", "yellow"))
        return

    # Find top bandwidth consumer
    top_device = max(device_stats, key=lambda k: device_stats[k]['total_bandwidth'])

    for ip, stats in sorted(device_stats.items(), key=lambda item: item[1]['total_bandwidth'], reverse=True):
        total_packets = stats['total_packets']
        total_bandwidth_kb = stats['total_bandwidth'] / 1024
        traffic_counts = stats['traffic_counts']
        
        highlight = " â­ Top Bandwidth Consumer" if ip == top_device else ""
        print(colored(f"\n--- Device: {ip}{highlight} ---", "green"))
        print(f"  Total Packets Sent: {total_packets}")
        print(f"  Total Bandwidth Used: {total_bandwidth_kb:.2f} KB")
        print("  Traffic Breakdown:")

        # Calculate total classified packets to get accurate percentages
        total_classified_packets = sum(traffic_counts.values())
        if total_classified_packets > 0:
            for traffic_type, count in sorted(traffic_counts.items(), key=lambda item: item[1], reverse=True):
                if count > 0:
                    percentage = (count / total_classified_packets) * 100
                    print(f"    - {traffic_type}: {count} packets ({percentage:.1f}%)")
    print(colored("\n" + "-" * 70, "cyan"))

def process_and_display_packet(packet, device_stats, bssid_filter=None):
    """Processes a single packet for heuristic analysis and prints the result."""
    # BSSID filter for targeted sniffing
    if bssid_filter and packet.haslayer(Dot11):
        if packet.type == 2: # Data frame
            # Check if the packet is coming from or going to the target BSSID
            if packet.addr1 != bssid_filter and packet.addr2 != bssid_filter:
                return
        else: # Not a data frame we are interested in for IP-level analysis
            return
    
    if not packet.haslayer(IP):
        return

    src_ip = packet[IP].src
    dst_ip = packet[IP].dst

    if src_ip not in device_stats:
        device_stats[src_ip] = {'total_packets': 0, 'total_bandwidth': 0, 'traffic_counts': {}}

    traffic_type, display_name = classify_packet(packet)

    if traffic_type not in device_stats[src_ip]['traffic_counts']:
        device_stats[src_ip]['traffic_counts'][traffic_type] = 0

    device_stats[src_ip]['total_packets'] += 1
    device_stats[src_ip]['total_bandwidth'] += len(packet)
    device_stats[src_ip]['traffic_counts'][traffic_type] += 1

    proto = packet.getlayer(IP).name
    port_info = ""
    if packet.haslayer(TCP): port_info = f"{packet[TCP].sport} -> {packet[TCP].dport}"
    elif packet.haslayer(UDP): port_info = f"{packet[UDP].sport} -> {packet[UDP].dport}"

    TYPE_COLORS = {
        'WhatsApp': 'green', 'Spotify': 'green', 'Instagram': 'magenta', 'Facebook': 'blue',
        'TikTok': 'white', 'Netflix': 'red', 'YouTube': 'red', 'InShot': 'yellow',
        'Browsing': 'green', 'Streaming Media': 'magenta', 'VoIP': 'cyan', 'File Transfer': 'yellow',
        'Email': 'blue', 'Gaming': 'red', 'Remote Access': 'white', 'DNS': 'green',
        'VPN / Tunneling': 'magenta', 'Cloud Services': 'cyan', 'Unknown': 'red'
    }
    type_color = TYPE_COLORS.get(traffic_type, 'white')
    print(
        f"{colored(src_ip, 'yellow'):<15} -> {colored(dst_ip, 'blue'):<15} "
        f"{colored(proto, 'red'):<5} {colored(port_info, 'cyan'):<17} "
        f"Type: {colored(display_name, type_color)}"
    )

def live_local_analysis():
    """Captures and analyzes traffic from this device only. Works on any network."""
    print(colored("\n--- Live Heuristic Analysis (This Device) ---", "cyan"))
    
    # 1. Get active network interface
    conn_iface, essid, _ = get_active_network_info()
    if not conn_iface:
        print(colored("[-] You are not connected to a network. Cannot analyze local traffic.", "red"))
        time.sleep(2)
        return
    
    print(colored(f"[*] Analyzing traffic on interface '{conn_iface}' for network '{essid}'.", "green"))

    try:
        duration_str = input(colored("Enter capture duration in seconds (e.g., 60): ", "blue"))
        duration = int(duration_str)
        if duration <= 0: raise ValueError
    except (ValueError, TypeError):
        print(colored("[-] Invalid duration. Please enter a positive number.", "red"))
        time.sleep(2)
        return

    device_stats = {}
    print(colored(f"\n[*] Starting local traffic analysis on {conn_iface} for {duration} seconds...", "green"))
    print(colored("Press Ctrl+C to stop early.", "blue"))
    print("-" * 80)
    try:
        sniff(iface=conn_iface, prn=lambda p: process_and_display_packet(p, device_stats), timeout=duration, store=False)
    except (PermissionError, OSError) as e:
        print(colored(f"[-] Error starting sniff on {conn_iface}: {e}. Do you have sufficient permissions?", "red"))
    except KeyboardInterrupt:
        print(colored("\n[*] Capture stopped by user.", "yellow"))
    except Exception as e:
        print(colored(f"An error occurred during sniffing: {e}", "red"))

    print("-" * 80)
    display_analysis_summary(device_stats)
    input(colored("\nPress Enter to return to the menu...", "blue"))

def live_lan_analysis():
    """Analyzes traffic from all devices on the current network (requires monitor mode)."""
    print(colored("\n--- Live Heuristic Analysis (All Devices on My Network) ---", "cyan"))
    print(colored("[!] This mode requires putting an interface into monitor mode.", "yellow"))
    print(colored("[!] On encrypted networks (WPA2/WPA3), you will likely only see your own traffic.", "yellow"))

    # 1. Get active network info
    conn_iface, essid, channel = get_active_network_info()
    if not channel:
        print(colored("[-] Could not determine the channel of an active WiFi network.", "red"))
        time.sleep(2)
        return
    
    bssid = get_connected_bssid(conn_iface)
    if not bssid:
        print(colored(f"[-] Could not determine the BSSID for network '{essid}'. Cannot target.", "red"))
        time.sleep(2)
        return

    print(colored(f"[*] Current network '{essid}' (BSSID: {bssid}) detected on channel {channel}.", "green"))

    # 2. Select a wireless interface for monitoring
    interfaces = get_all_wireless_interfaces()
    if not interfaces:
        print(colored("[-] No wireless interfaces found. Cannot proceed.", "red"))
        time.sleep(2)
        return

    print(colored("\n[*] Available wireless interfaces for monitoring:", "blue"))
    for i, iface in enumerate(interfaces):
        print(f"  {i}. {iface}")
    try:
        choice = int(input(f"[*] Select an interface to use for monitoring: "))
        monitor_interface = interfaces[choice]
    except (ValueError, IndexError):
        print(colored("[-] Invalid selection.", "red"))
        return

    # 3. Set monitor mode and sniff
    device_stats = {}
    try:
        if not set_monitor_mode(monitor_interface, channel):
            return

        try:
            duration_str = input(colored("Enter capture duration in seconds (e.g., 60): ", "blue"))
            duration = int(duration_str)
            if duration <= 0: raise ValueError
        except (ValueError, TypeError):
            print(colored("[-] Invalid duration.", "red"))
            return

        print(colored(f"\n[*] Starting LAN traffic analysis on {monitor_interface} for {duration} seconds...", "green"))
        print(colored("Press Ctrl+C to stop early.", "blue"))
        print("-" * 80)
        
        sniff(iface=monitor_interface, prn=lambda p: process_and_display_packet(p, device_stats, bssid_filter=bssid), timeout=duration, store=False)

    except (PermissionError, OSError, KeyboardInterrupt) as e:
        if isinstance(e, KeyboardInterrupt):
            print(colored("\n[*] Capture stopped by user.", "yellow"))
        else:
            print(colored(f"[-] A critical error occurred: {e}", "red"))
    finally:
        set_managed_mode(monitor_interface)

    print("-" * 80)
    display_analysis_summary(device_stats)
    input(colored("\nPress Enter to return to the menu...", "blue"))

def live_targeted_analysis():
    """Launches the Bettercap service and the live security analyzer."""
    print(colored("\n--- Live Security Analyzer ---", "cyan"))
    print(colored("[*] This mode will automatically start Bettercap and then launch the analyzer.", "blue"))

    try:
        # --- Step 1: Check for required files ---
        bettercap_script = "bettercap_auto.sh"
        analyzer_script = "live_traffic_analyzer.py"
        venv_python = os.path.join("venv", "bin", "python")

        if not os.path.exists(bettercap_script):
            print(colored(f"[-] Error: '{bettercap_script}' not found.", "red"))
            time.sleep(2)
            return
        if not os.path.exists(analyzer_script):
            print(colored(f"[-] Error: '{analyzer_script}' not found.", "red"))
            time.sleep(2)
            return
        if not os.path.exists(venv_python):
            print(colored("[-] Virtual environment not found. Please create it first.", "red"))
            print(colored("    Run: python3 -m venv venv", "yellow"))
            time.sleep(3)
            return

        # --- Step 2: Launch Bettercap in a new terminal ---
        print(colored("\n[*] Launching Bettercap automation script...", "blue"))
        print(colored("    A new terminal will open. You may be prompted for your sudo password.", "yellow"))
        
        try:
            # Make the script executable
            os.chmod(bettercap_script, 0o755)
            
            # Command to run Bettercap with sudo in a new terminal
            bettercap_cmd = ["gnome-terminal", "--", "sudo", "./" + bettercap_script]
            subprocess.Popen(bettercap_cmd)
            print(colored("[+] Bettercap script launched. Please check the new terminal window.", "green"))

            # --- Step 3: Wait for Bettercap to initialize ---
            print(colored("[*] Waiting 15 seconds for Bettercap to initialize its API...", "blue"))
            time.sleep(15)

            # --- Step 4: Launch the Python analyzer ---
            print(colored("\n[*] Launching the Python traffic analyzer...", "blue"))
            env = copy.deepcopy(os.environ)
            env['LC_ALL'] = 'C.UTF-8'
            env['LANG'] = 'C.UTF-8'
            
            analyzer_cmd_str = f"{venv_python} {analyzer_script}; echo; echo '[INFO] Analysis script finished.'; echo 'Press Enter to close.'; read"
            analyzer_cmd = ["gnome-terminal", "--", "bash", "-c", analyzer_cmd_str]
            subprocess.Popen(analyzer_cmd, env=env)
            print(colored("[+] Analyzer launched in a second terminal window.", "green"))
            time.sleep(3)

        except FileNotFoundError:
            print(colored("\n[!] 'gnome-terminal' not found. This feature requires it.", "red"))
            print(colored("    Please run './bettercap_auto.sh' manually in one terminal,", "yellow"))
            print(colored("    and then run the analyzer from the menu in another.", "yellow"))
            time.sleep(5)
        except Exception as e:
            print(colored(f"[-] An error occurred during launch: {e}", "red"))
            time.sleep(2)

    except KeyboardInterrupt:
        print(colored("\n[!] Operation cancelled by user.", "yellow"))
    except Exception as e:
        print(colored(f"[-] An unexpected error occurred: {e}", "red"))
        time.sleep(2)

def capture_packets_to_file():
    """Provides options to capture packets to a file using Scapy or by launching Wireshark."""
    print(colored("\n--- Capture Packets to File ---", "cyan"))

    print("1. Use this script to capture (Scapy)")
    print("2. Launch Wireshark GUI for capture")
    choice = input(colored("Enter your choice: ", "blue"))

    if choice == '1':
        capture_with_scapy()
    elif choice == '2':
        launch_wireshark()
    else:
        print(colored("[-] Invalid choice.", "red"))

def capture_with_scapy():
    """Captures network packets using Scapy and saves them to a .pcap file."""
    interfaces = get_all_wireless_interfaces()
    if not interfaces:
        print(colored("[-] No wireless interfaces found to capture from.", "red"))
        time.sleep(2)
        return

    print(colored("\n[*] Available interfaces:", "blue"))
    for i, iface in enumerate(interfaces):
        print(f"  {i}. {iface}")
    try:
        choice = int(input("[*] Select an interface to capture on: "))
        interface = interfaces[choice]
    except (ValueError, IndexError):
        print(colored("[-] Invalid selection.", "red"))
        return

    try:
        duration_str = input(colored("Enter capture duration in seconds (e.g., 60): ", "blue"))
        duration = int(duration_str)
        if duration <= 0: raise ValueError
    except (ValueError, TypeError):
        print(colored("[-] Invalid duration.", "red"))
        time.sleep(2)
        return

    output_file = f"capture_{interface}_{int(time.time())}.pcap"
    print(colored(f"[*] Starting packet capture on {interface} for {duration} seconds...", "green"))
    print(colored(f"[*] Packets will be saved to '{output_file}'. Press Ctrl+C to stop early.", "blue"))

    try:
        packets = sniff(iface=interface, timeout=duration)
        wrpcap(output_file, packets)
        print(colored(f"\n[+] Capture complete. {len(packets)} packets saved to '{output_file}'.", "green"))
    except (PermissionError, OSError):
        print(colored(f"[-] Error: You need root privileges to capture packets on '{interface}'.", "red"))
    except KeyboardInterrupt:
        print(colored("\n[*] Capture stopped by user.", "yellow"))
    except Exception as e:
        print(colored(f"\n[-] An error occurred: {e}", "red"))
    finally:
        input(colored("\nPress Enter to return to the menu...", "blue"))

def launch_wireshark():
    """Launches the Wireshark GUI for interactive packet capture."""
    print(colored("[*] Attempting to launch Wireshark...", "blue"))
    try:
        # Use Popen to launch Wireshark in the background without blocking the script
        subprocess.Popen(['wireshark'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        print(colored("[+] Wireshark has been launched.", "green"))
        print(colored("[*] Please use the Wireshark interface to start, stop, and save your capture.", "yellow"))
    except FileNotFoundError:
        print(colored("[-] Error: 'wireshark' command not found.", "red"))
        print(colored("[*] Please ensure Wireshark is installed and in your system's PATH.", "blue"))
    except Exception as e:
        print(colored(f"[-] Failed to launch Wireshark: {e}", "red"))
    
    input(colored("\nPress Enter to return to the menu...", "blue"))

def handle_live_analysis_menu():
    """Presents the menu for different live analysis modes."""
    while True:
        print("\n--- Live Heuristic Analysis Menu ---")
        print("1. Analyze This Device's Traffic (Works on any network)")
        print("2. Analyze All Devices on My WiFi (Requires monitor mode)")
        print("0. Back to Main Menu")

        choice = input(colored("Enter your choice: ", "blue"))

        if choice == '1':
            live_local_analysis()
            break
        elif choice == '2':
            live_lan_analysis()
            break
        elif choice == '0':
            break
        else:
            print(colored("[-] Invalid choice. Please try again.", "red"))

def analyze_pcap_file():
    """Analyzes a .pcap file using the heuristic engine."""
    print(colored("\n--- Analyze .pcap File ---", "cyan"))
    try:
        file_path = input(colored("Enter the path to the .pcap/.pcapng file (default: hello.pcapng): ", "blue"))
        if not file_path:
            file_path = 'hello.pcapng'

        if not os.path.exists(file_path):
            print(colored(f"[-] Error: File not found at '{file_path}'.", "red"))
            time.sleep(2)
            return

        print(colored(f"[*] Reading packets from '{file_path}'...", "green"))
        packets = rdpcap(file_path)
        print(colored(f"[*] Found {len(packets)} packets. Starting analysis...", "green"))
        print("-" * 80)

        device_stats = {}
        for packet in packets:
            process_and_display_packet(packet, device_stats)

        print("-" * 80)
        display_analysis_summary(device_stats)

    except Scapy_Exception as e:
        print(colored(f"[-] Error reading pcap file: {e}", "red"))
    except Exception as e:
        print(colored(f"[-] An unexpected error occurred: {e}", "red"))
    
    input(colored("\nPress Enter to return to the menu...", "blue"))

def handle_traffic_analysis_menu():
    """Displays the menu for traffic analysis options."""
    while True:
        os.system('clear' if os.name == 'posix' else 'cls')
        print(colored("--- ðŸ•µï¸ Traffic Analysis Menu ---", "cyan"))
        print("  (1) Live Heuristic Analysis")
        print("  (2) Analyze .pcap File")
        print("  (3) Capture Packets to File")
        print("  (4) Back to Main Menu")
        choice = input(colored("\nEnter your choice: ", "blue")).strip()

        if choice == '1':
            handle_live_analysis_menu()
        elif choice == '2':
            analyze_pcap_file()
        elif choice == '3':
            capture_packets_to_file()
        elif choice == '4':
            return
        else:
            print(colored("[-] Invalid choice. Please try again.", "red"))
            time.sleep(2)

def print_banner():
    """Prints the colorful AIR AUDIT banner."""
    banner_art = [
        "    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—",
        "   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ•â•â–ˆâ–ˆâ•”â•â•â•",
        "   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘   ",
        "   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘   ",
        "   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘   ",
        "   â•šâ•â•  â•šâ•â•â•šâ•â•â•šâ•â•  â•šâ•â•     â•šâ•â•â•â•â•  â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•    â•šâ•â•   "
    ]
    for line in banner_art:
        print(colored(line, 'green'))
    print(colored("by Group 3".center(80), "yellow"))
    print()

def main():
    check_dependencies()
    print_banner()

    try:
        while True:
            print(colored("\n--- Main Menu ---", "cyan"))
            print("  (1) Real-time LAN Monitor (Device Discovery & Deauth)")
            print("  (2) Live Traffic Analysis (Heuristic Engine)")
            print("  (3) Live Security Analyzer (Bettercap)")
            print("  (4) Analyze Existing .pcap File")
            print("  (5) Capture Packets to File")
            print("  (6) Exit")

            choice = input(colored("\nSelect an option: ", "blue")).strip()

            if choice == '1':
                run_real_time_monitor()
            elif choice == '2':
                handle_live_analysis_menu()
            elif choice == '3':
                live_targeted_analysis()
            elif choice == '4':
                analyze_pcap_file()
            elif choice == '5':
                capture_packets_to_file()
            elif choice == '6':
                print(colored("\n[*] Goodbye!", "green"))
                break
            else:
                print(colored("[-] Invalid choice. Please try again.", "red"))

    except KeyboardInterrupt:
        print(colored("\n\n[!] Program interrupted by user. Exiting.", "yellow"))
    except Exception as e:
        print(colored(f"\n[-] An unexpected error occurred in main: {e}", "red"))
    finally:
        # Attempt to find any monitor-mode interface and restore it
        interfaces = get_all_wireless_interfaces()
        restored = False
        for iface in interfaces:
            try:
                # A simple check to see if it might be in monitor mode
                output = subprocess.check_output(["iwconfig", iface], stderr=subprocess.STDOUT).decode()
                if "Mode:Monitor" in output:
                    print(colored(f"\n[!] Found interface '{iface}' in monitor mode. Attempting to restore...", "yellow"))
                    set_managed_mode(iface)
                    restored = True
            except Exception:
                continue # Ignore errors during cleanup
        
        if restored:
            print(colored("[*] Cleanup complete.", "green"))

if __name__ == "__main__":
    main()
